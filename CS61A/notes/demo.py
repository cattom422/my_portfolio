from math import *
#just grammars
a=[[2],[2,3]]
print(sum(a,[]))#start is by default int 0
a=list(range(100))
print(max(a,key=lambda x:sqrt(x)))#mind blowing!
print(all(a))
print("234" in "12345?")
#{<key exp>:<value exp> for <value> in <iter exp> if <filter exp>}
#data abstraction, another way of abstraction
#1.Function Abstraction: Break down your code into
#reusable functions or methods. Each function 
#should perform a specific task, allowing you to 
#focus on what the function does rather than how it does it.
#(methods)

#2.Data Abstraction: Use data structures 
#(like classes, structs, or dictionaries) to encapsulate 
#data and behavior. This hides the internal representation 
#and exposes only the necessary interface.
#(data)

#and more to come.

#an Abstract Data type lets us manipulate Compound Objects
#As UNITS.

#constructor & selector
#前者构建抽象数据结构（造），后者解构并加以利用
# pair=[1,2]
# x,y=pair#unpacking
# #rational number
# def rational(n,d):
#     return [n,d]
# def numer(x):
#     return x[0]
# def denom(x):
#     return x[1]
# #约分有理数
# from fractions import gcd
# def rational(n,d):
#     g=gcd(n,d)
#     return [n//g,d//g]#not / for it is int, and to not include .

#abstraction barriers
#在使用抽象数据进行抽象计算时将其看作一个整体
#在使用抽象数据进行具体计算时将利用selector
#在实现功能时则要完全具象化
#牛

#TREE
#a tree has a root label and a list of branches.
#each branch is a tree(idea of recursion)
#constructor be like:tree(3,[tree(1),tree(2,...)])
def tree(label,branches=[]):#not nessarily a binary tree.
    for branch in branches:#leaf belike [number]
        assert is_tree(branch), 'branches must be trees.'
    return [label]+list(branches)
def label(tree):
    return tree[0]
def branches(tree):
    return tree[1:]
def is_tree(tree):
    if type(tree)!=list or len(tree)<1:
        return False
    for branch in branches(tree):
        if not is_tree(branch):
            return False
    return True
def is_leaf(tree):
    return not branches(tree)
print(tree(1),tree(1,[tree(1)]))#外面这层就像是糖纸。
#printing trees
def fib_trees(n):
    if n<=1:
        return tree(n)
    else:
        left,right=fib_trees(n-2),fib_trees(n-1)
        return tree(label(left)+label(right),[left,right])
# print(fib_trees(10))
def count_leaves(t):
    if is_leaf(t):
        return 1
    else:#don't know how many branches!
        return sum([count_leaves(b) for b in branches(t)])
def leaves(tree):
    if is_leaf(tree):
        return [label(tree)]
    else:
        return sum([leaves(b) for b in branches(tree)],[])
def print_trees(t,depth=0):
    print(" "*depth+str(label(t)))
    for b in branches(t):
        print_trees(b,depth+1)
def count_paths(t,total):
    if label(t)==total:
        found=1
    else:
        found=0
    return found+sum([count_paths(b,total-label(t)) for b in branches(t)])
#Recursion did by 
#1.manipulating the return value 
#2.pass the result into the argument
def fact_times(n,k):
    # return k*n*(n-1)* ... *1
    if n==0:
        return k
    else:
        return fact_times(n-1,k*n)
def fact(n):
    return fact_times(n,1)
def facto(n,cur):
    if n==0:
        return cur#cool!Better to think this way!!!
    else:
        return facto(n-1,n*cur)

# project02 cats
#1.always remember to add index examination when iterating
    #same idea when doing recursion, examine the base condition.
#2.print不会打印出‘’，而控制台会。

#Mutability
#Objects  
    #attribute bound to objects
    #methods: attribute bound to functions(mutate the object, while returning None.)
        # should make it clear that function is different from methods, since methods return nothing.
        # however, there's method that returns non-Nonetype, like upper()
from datetime import date
# date->class
today = date(2015,2,20)#objects
freedom=date(2015,5,12)
# str(freedom-today)
# today.year 
# today.strftime('%A %B %d')

#Objects represent information
#consists of data and behavior, bundled together to create abstractions
# (after function & data abstraction, like conbined them together to increase the level of abstraction)
# Objects can represent things, but also properties, interactions, & processes.
# a type of object is called a class;(even higher level of abstraction)
# OOP
    # A metaphor for organizing large programs
# Every value in python is an object

# Mutation Operations
suits=['coin']
suits.pop()
suits.extend(['sword','club'])
# All names that refer to the same object are affected by a mutation.
#!
# dict.pop(key)

# tuples are immutable sequences.
#dict only allows immutable objects, like tuples(no list inside that tuple) and ...
# 'is' to see if two are bound to the same object
# Identity vs Equality
# id() shows the address.

# a default argument value is part of a function value, not generated by a call.
def f(s=[]):
    s.append(3)
    return len(s)
f()
f()
f()#1 2 3

# A function with behavior that varies over time!
def make_withdraw_list(balance):
    b=balance
    def withdraw(amount):
        if amount>b:
            return 'No money!'
        b-=amount
        return b
    return withdraw
# vs
def make_withdraw_list(balance):
    b=[balance]
    def withdraw(amount):
        if amount>b[0]:
            return 'No money!'
        b[0]-=amount
        return b[0]
    return withdraw
withdraw=make_withdraw_list(100)
withdraw(25)
# Why This Works:
# Python only raises a UnboundLocalError if you reassign 
# a variable (e.g., b = new_value) in a nested function
# while Python expects it to be a local variable.

# However, mutating the contents of b (like b[0] -= amount) 
# doesn't count as reassignment. The list object remains the 
# same, so the interpreter does not treat b as local.



# Iterators
# iterates things 
# s=[1,2,3]
# t=iter(s)
# next(t)
# 3->4->5
# be similar to a linked list, things before will not be remembered
#list(iter) will use up the iterator and what's left in iter is []
# when iterating, it's illegal to change the size/content of the iterator.
# range certainly can be iterated, and more importantly, for statement can iterate iterators

# many processing of sequences and other iterable values used built-in iterators take in one iterable object and return an iterator
# but it computes results lazily...
# compute it when called rather than created...
# it's interesting to make attributes to be a function
f=lambda x:x.upper()
# 'lazy computation' can be convenient while still should be careful about
t=[1,2,1]
print(reversed(t)==t)
# false!
# because it was lazily computed, so reversed(t) is currently a list_reversediterator
a=zip(range(2),range(10)) #cool function
# 回文字符串
def palindrome(s):
    return all([a==b for a,b in zip(s,reversed(s))])

# when to use iterators?(for & iter)
# well, actually it abstracts, too<- all iterable objects are available here, without confirming its exact data type.
# also, it bundles up a sequence aand a position as an object.
    # which means passing that object to another func retains the position
    # calls only once.
    # only available for next() and no changes can be performed on that one
# a great place to use it: distributing poke...